\chapter{Design and Implementation}
\label{chap:design}

Our design is inspired from the maildir format~\cite{bernstein1995using}. The maildir format stores each message in a separate file with a unique name. The mail user agent (MUA) does not have to worry about partially delivered mail: each message is safely written to disk in the \textit{tmp} subdirectory before it is moved to \textit{new}. When a mail user agent process finds message in the \textit{new} subdirectory, it moves them to \textit{curr}.

Similar to maildir, we also store all large objects in separate files. All the large objects of a database are stored under a single directory which we also call a ``BlobStore''.
The BlobStore contains three subdirectories: \textit{tmp}, \textit{curr} and \textit{gc}. We will discuss purpose of these directories later in this chapter.

\section{Initializing the BlobStore}
Before starting to create blobs inside a directory, we ensure that the \textit{tmp} and \textit{curr} subdirectories have already been created. We provide a method \texttt{openBlobStore} which takes the path of a directory which is to be used as BlobStore as argument and does the initialization for us.
BlobStore is defined as a newtype. We don't expose the constructor for BlobStore, so the only way to get a BlobStore is by using the \texttt{openBlobStore} method.

\begin{program}
  \caption{Definition of BlobStore}
  \label{prog:defblobstore}
  \inputminted{haskell}{hs/blobstore.hs}
\end{program}

\section{Creating a new Blob}
We provide a method called \texttt{newBlob} for creating a new blob. It takes a BlobStore as a parameter and returns a WriteContext.

\begin{program}
  \caption{Definition of WriteContext}
  \label{prog:defwritecontext}
  \inputminted{haskell}{hs/writecontext.hs}
\end{program}

WriteContext contains the file handle of just created blob, a TempLocation and a hashCtx. TempLocation stores the base directory and the filename of just created blob. The hashCtx is used to store the SHA-512 hash of the contents that has been written to the blob.

All the new blobs are created in the \textit{tmp} folder. We use Version 4 UUID~\cite{leach2005universally} to give unique names to the newly created blobs.

\section{Writing to a Blob}
Since the blobs can be very large, it is possible that the entire blob will not fit in the main memory. Hence, we provide an incremental interface for writing to a blob.

We only allow to add new data at the end of a given blob. \texttt{writePartial} takes a blob and a WriteContext as arguments and appends the given blob to the WriteContext's blob.

Once all the data has been written to the blob, \texttt{endWrite} is called. \texttt{endWrite} takes a WriteContext as argument and moves the blob from \textit{tmp} folder to \textit{curr} folder. Before moving the blob, we ensure that all the data has been written to disk by calling the \texttt{fsync} system call.

In \texttt{endWrite}, we also rename the file to SHA-512 hash of its contents. Using hash of the contents as filename ensures that if multiple blobs have same contents, only one copy is stored. We also prefix the filename with the name of the hash function i.e. ``sha-512''. This is for future compatibility, in case we want to support other hash functions.

\texttt{endWrite} returns a BlobId. This BlobId contains the location of the blob. No more updates to the blob are possible after calling \texttt{endWrite}.

\begin{program}
  \caption{Definition of BlobId}
  \label{prog:defblobid}
  \inputminted{haskell}{hs/blobid.hs}
\end{program}

\begin{figure}[hbt]
  \caption{Directory structure of a BlobStore}
  \label{fig:blobstore-dirstructure}
  \dirtree{%
    .1 blobstore.
    .2 tmp.
    .3 f66affb7-ad10-4583-8986-c4a6892d0120.
    .2 curr.
    .3 sha512-a75ebf9a0f109288d3eae1ecbfd89....
  }
\end{figure}

\section{Reading from Blob}
Similar to writes, reading is also incremental. First the \texttt{startRead} method is called which takes a BlobId as argument and returns a ReadContext. ReadContext contains the file handle of the blob which is opened in read mode.

\begin{program}
  \caption{Definition of ReadContext}
  \label{fig:defreadcontext}
  \inputminted{haskell}{hs/readcontext.hs}
\end{program}

\texttt{readPartial} takes a ReadContext and number of bytes as input and returns those number of bytes from the blob.
While reading from a blob, you can skip ahead using the method \texttt{skipBytes}. \texttt{skipBytes} takes a ReadContext and number of bytes, \textit{b} as input and skips \textit{b} bytes ahead in the ReadContext.
The \texttt{endRead} method closes the open handle.

\begin{table}[hbt]
\caption{Interface for operations on blob}
\label{tab:interface-blob}
\begin{center}
  \begin{tabularx}{0.91\textwidth}{lX}
    \hline\noalign{\smallskip}
    Method & Purpose \\
    \noalign{\smallskip}
    \hline
    \noalign{\smallskip}
    \texttt{openBlobStore} & Initializes given directory to be used as a BlobStore \\
    \texttt{newBlob} & Creates a blob in the given BlobStore\\
    \texttt{writePartial} & Takes a blob and appends it to the end of the blob given in the argument\\
    \texttt{endWrite} & Takes a WriteContext as input and returns a BlobId \\
    \texttt{startRead} & Takes a BlobId as input and returns a ReadContext \\
    \texttt{readPartial} & Reads a given number of bytes from a Blob \\
    \texttt{skipBytes} & Skips ahead a given number of bytes in a Blob \\
    \texttt{endRead} & Completes the read \\
    \hline
  \end{tabularx}
\end{center}
\end{table}

\begin{figure}
  \caption{Order of operations on Blob}
  \label{fig:blob-operations-order}
  \begin{tikzpicture}[>=latex]
    \tikzset{ block/.style= {draw, rectangle, align=center, minimum width=3cm, minimum height=1cm}
    },
    \node [block] (openBlobStore) {openBlobStore};
    \node [block, right =1.5cm of openBlobStore] (newBlob) {newBlob};
    \node [block, right =1.5cm of newBlob] (writePartial) {writePartial};
    \node [block, right =1.5cm of writePartial] (endWrite) {endWrite};
    \node [block, below =2.5cm of endWrite] (startRead) {startRead};
    \node [block, above left =0.5cm and 1.5cm of startRead] (readPartial) {readPartial};
    \node [block, below left =0.5cm and 1.5cm of startRead] (skipBytes) {skipBytes};
    \node [block, below left =0.5cm and 1.5cm of readPartial] (endRead) {endRead};

    \path[draw,->] (openBlobStore) edge (newBlob)
                   (newBlob) edge (writePartial)
                   (writePartial) edge [loop above] (writePartial)
                   (writePartial) edge (endWrite)
                   (endWrite) edge (startRead)
                   (startRead) edge (readPartial)
                   (startRead) edge (skipBytes)
                   (readPartial) edge [loop above] (readPartial)
                   (skipBytes) edge [bend right] (readPartial)
                   (readPartial) edge [bend right] (skipBytes)
                   (readPartial) edge (endRead)
                   ;
  \end{tikzpicture}
\end{figure}

\section{Helper methods for small blobs}
Blobs which can easily fit into the main memory, do not require the incremental write and read methods. For such blobs, we provide helper methods \texttt{createBlob} and \texttt{readBlob}.

\texttt{createBlob} takes a BlobStore and the blob contents as arguments and returns the BlobId of the newly created blob. It basically combines the newBlob, writePartial and endWrite methods.

\begin{program}
  \caption{Definition of createBlob}
  \label{fig:defcreateblob}
  \inputminted{haskell}{hs/createblob.hs}
\end{program}

\texttt{readBlob} takes a BlobId as argument and returns its entire contents.

\begin{table}[hbt]
\caption{Helper methods for small blobs}
\label{tab:interface-small-blob}
\begin{center}
  \begin{tabularx}{0.91\textwidth}{lX}
    \hline\noalign{\smallskip}
    Method & Purpose \\
    \noalign{\smallskip}
    \hline
    \noalign{\smallskip}
    \texttt{createBlob} & Creates a blob with a given content in a BlobStore \\
    \texttt{readBlob} & Takes a BlobId as argument and reads its entire contents \\
    \hline
  \end{tabularx}
\end{center}
\end{table}

\section{Garbage Collection}
It is quite likely that the same blob would be shared by multiple ``values'' in the database. For a relational database these values are rows in a table, while for a document-oriented database, these values are documents.
Hence, we provide an interface for garbage collecting the deleted blobs.

\subsection{Starting the Garbage Collection}
The \texttt{startGC} method takes a BlobStore as argument and starts garbage collection (GC) for that BlobStore.
\texttt{startGC} does two things: It first creates the \textit{gc} folder and then creates empty files in the \textit{gc} folder corresponding to every blob in the \textit{curr} folder.
We use the \texttt{readdir} system call to iterate through the contents of the \textit{curr} folder.
Once a GC has started you can not start another GC on the same BlobStore until the first one finishes - doing so will throw an error. Also, note that creation of new blobs and reading the old blobs can happen concurrently with the GC.

\begin{figure}[hbt]
  \caption{Directory structure of a BlobStore during GC}
  \label{fig:blobstore-dirstructure-gc}
  \dirtree{%
    .1 blobstore.
    .2 tmp.
    .3 1a4c5091-1295-4c9c-b8d3-8e6123a51b41.
    .2 gc.
    .3 sha512-11853df40f4b2b919d3815f64792e....
    .2 curr.
    .3 sha512-11853df40f4b2b919d3815f64792e....
    .3 sha512-9b71d224bd62f3785d96d46ad3ea3....
  }
\end{figure}

\subsection{Marking a blob as accessible}
Once a blob is marked as not deleted using the method \texttt{markAsAccessible}, we delete the file corresponding to that blob from \texttt{gc} directory. This ensures that the blob does not get deleted at the end of the GC.

\subsection{End Garbage collection}
This step involves removal of all the blobs which are not accessible. The \texttt{endGC} method takes a BlobStore as argument. It iterates over all files in the \textit{gc} directory and deletes the corresponding blob from the \textit{curr} directory.
After this step finishes, \texttt{endGC} deletes the \textit{gc} directory along with its contents.

\begin{table}[hbt]
\caption{Interface for garbage collection}
\label{tab:interface-gc}
\begin{center}
  \begin{tabularx}{0.91\textwidth}{lX}
    \hline\noalign{\smallskip}
    Methods & Purpose \\
    \noalign{\smallskip}
    \hline
    \noalign{\smallskip}
    \texttt{startGC} & Starts garbage collection for the given BlobStore\\
    \texttt{markAsAccessible} & Marks the given blob as accessible\\
    \texttt{endGC} & Ends the garbage collection by removing all the unaccessible blobs\\
    \hline
  \end{tabularx}
\end{center}
\end{table}

\section{Concurrency}
In this section we will describe how the design described above allows concurrent access on blobs across processes.

The \texttt{newBlob} creates an empty file in the \textit{tmp} folder. This method will never fail, as we ensure that the \textit{tmp} folder is always present.
In \texttt{endWrite}, we move the blob to \textit{curr} folder. We use the \texttt{rename} system call for this, which is atomic i.e. a partial file will never be read ~\cite{renamemanpage}.
Before moving the blob to \textit{curr}, we mark it as accessible using \texttt{markAsAccessible}, otherwise it will get deleted when \texttt{endGC} is called.

\texttt{startGC} first creates an empty \textit{gc} directory using \texttt{mkdir}. We rely on \texttt{mkdir} to be atomic i.e. if two processes try to create the \textit{gc} directory simultaneously, only one of them will succeed.
This ensures that at any instance, only one GC can be running.
We then traverse the \textit{curr} directory using \texttt{readdir} system call and create an empty file with same name in \textit{gc} directory. Note that \texttt{readdir} is not thread-safe. However, in our implementation only one GC will be running at any instance, thread safety of \texttt{readdir} is immaterial.

In \texttt{endGC}, we traverse the \textit{gc} directory and delete the corresponding file from \textit{curr} directory. It might happen that a blob which was opened for reading by \texttt{startRead} gets deleted during \texttt{endGC}.
We use the \texttt{unlink} system call for removing the file. \texttt{unlink} ensures that the file remains in existence until the last file descriptor referring to it is closed ~\cite{unlinkmanpage}.
