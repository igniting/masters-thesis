\chapter{Design}
\label{chap:design}

We store all the large objects in separate files. Our design is inspired from the maildir format~\cite{bernstein1995using}. All the large objects of a database are stored under a single directory which we also call a ``BlobStore''.
The BlobStore contains three subdirectories: \textit{tmp}, \textit{curr} and \textit{old}. We will discuss purpose of this directories later in this chapter.

\section{Creating a Blob}
We provide a method called \texttt{createBlob} for creating a new blob. It takes a BlobStore as a parameter and returns a WriteContext. WriteContext contains the file handle of just created blob among other things. All the new blobs are created in the \textit{tmp} folder. We use UUID-4 to give unique names to the newly created blobs.

\section{Writing to a Blob}
We only allow to add new data to the end of a given blob. We provide \texttt{writePartial} method for this. \texttt{writePartial} takes a blob and a WriteContext as arguments and appends the given blob to the WriteContext's blob.
Once all the data has been written to the blob, \texttt{finalizeWrite} is called. \texttt{finalizeWrite} takes a WriteContext as argument and moves the blob from \textit{tmp} folder to \textit{curr} folder. We also rename the file to SHA-512 hash of it's contents.
\texttt{finalizeWrite} returns a BlobId. This BlobId contains the location of the blob.

\section{Reading from Blob}
Reading is also sequential. First the \texttt{initRead} method is called which returns a ReadContext, similar to the WriteContext. ReadContext also contains the file handle of the blob which is opened in read mode.
\texttt{readPartial} takes a ReadContext and number of bytes as input and returns those number of bytes from the blob.

\begin{table}[hbt]
\caption{Interface for operations on blob}
\label{tab:interface-blob}
\begin{center}
  \begin{tabularx}{0.91\textwidth}{lX}
    \hline\noalign{\smallskip}
    Methods & Purpose \\
    \noalign{\smallskip}
    \hline
    \noalign{\smallskip}
    \texttt{createBlob} & Creates a blob in the given BlobStore\\
    \texttt{writePartial} & Takes a blob and appends it to the end of the blob given in the argument\\
    \texttt{finalizeWrite} & Takes a WriteContext as input and returns a BlobId \\
    \texttt{initRead} & Takes a BlobId as input and returns a ReadContext \\
    \texttt{readPartial} & Reads a given number of bytes from a Blob \\
    \texttt{finalizeRead} & Completes the read \\
    \hline
  \end{tabularx}
\end{center}
\end{table}

\section{Garbage Collection}

\begin{table}[hbt]
\caption{Interface for garbage collection}
\label{tab:interface-gc}
\begin{center}
  \begin{tabularx}{0.91\textwidth}{lX}
    \hline\noalign{\smallskip}
    Methods & Purpose \\
    \noalign{\smallskip}
    \hline
    \noalign{\smallskip}
    \texttt{startGC} & Starts garbage collection for the given BlobStore\\
    \texttt{markBlobAsAccessible} & Marks the given blob as accessible\\
    \texttt{endGC} & Ends the garbage collection by removing all the unaccessible blobs\\
    \hline
  \end{tabularx}
\end{center}
\end{table}
